package filters

import (
	"context"
	"database/sql"
	"fmt"
	"kessler/database"
	"kessler/gen/dbstore"

	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// Common errors that can be returned by the FilterService
var (
	ErrFilterNotFound     = fmt.Errorf("filter not found")
	ErrInvalidFilterState = fmt.Errorf("invalid filter state")
	ErrDatabaseOperation  = fmt.Errorf("database operation failed")
)

// FilterService handles business logic for filters
type FilterService struct {
	db          *pgxpool.Pool
	registry    *FilterRegistry
	queryEngine *dbstore.Queries // This will be generated by sqlc
	logger      *zap.Logger
}

// NewFilterService creates a new instance of FilterService
func NewFilterService(db *pgxpool.Pool, registry *FilterRegistry, logger *zap.Logger) *FilterService {
	qe := database.GetTx()
	return &FilterService{
		db:          db,
		registry:    registry,
		queryEngine: qe,
		logger:      logger.With(zap.String("component", "filter_service")),
	}
}

// GetFiltersByState retrieves filters by their state
func (s *FilterService) GetFiltersByState(ctx context.Context, state string) ([]dbstore.Filter, error) {
	if state == "" {
		return nil, fmt.Errorf("%w: empty state", ErrInvalidFilterState)
	}

	s.logger.Debug("fetching filters by state",
		zap.String("state", state))

	filters, err := s.queryEngine.GetFiltersByState(ctx, state)
	if err != nil {
		if err == sql.ErrNoRows {
			return []dbstore.Filter{}, nil
		}
		s.logger.Error("failed to fetch filters",
			zap.String("state", state),
			zap.Error(err))
		return nil, fmt.Errorf("%w: %v", ErrDatabaseOperation, err)
	}

	return filters, nil
}
