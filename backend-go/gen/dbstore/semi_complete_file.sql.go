// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: semi_complete_file.sql

package dbstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getFileWithMetadata = `-- name: GetFileWithMetadata :one
SELECT public.file.id,
    public.file.name,
    public.file.extension,
    public.file.lang,
    public.file.verified,
    public.file.hash,
    public.file.isPrivate,
    public.file.created_at,
    public.file.updated_at,
    public.file_metadata.mdata
FROM public.file
    LEFT JOIN public.file_metadata ON public.file.id = public.file_metadata.id
WHERE public.file.id = $1
`

type GetFileWithMetadataRow struct {
	ID        pgtype.UUID
	Name      pgtype.Text
	Extension pgtype.Text
	Lang      pgtype.Text
	Verified  pgtype.Bool
	Hash      pgtype.Text
	Isprivate pgtype.Bool
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Mdata     []byte
}

func (q *Queries) GetFileWithMetadata(ctx context.Context, id pgtype.UUID) (GetFileWithMetadataRow, error) {
	row := q.db.QueryRow(ctx, getFileWithMetadata, id)
	var i GetFileWithMetadataRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Extension,
		&i.Lang,
		&i.Verified,
		&i.Hash,
		&i.Isprivate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Mdata,
	)
	return i, err
}

const semiCompleteFileGet = `-- name: SemiCompleteFileGet :many
SELECT 
    public.file.id,
    public.file.name,
    public.file.extension,
    public.file.lang,
    public.file.verified,
    public.file.hash,
    public.file.created_at,
    public.file.updated_at,
    public.file_metadata.mdata,
    public.file_extras.extra_obj,
    public.docket_documents.docket_id as docket_uuid,
    public.relation_documents_organizations_authorship.is_primary_author,
    public.organization.id as organization_id,
    public.organization.name as organization_name,
    public.organization.is_person
FROM public.file
    LEFT JOIN public.file_metadata ON public.file.id = public.file_metadata.id
    LEFT JOIN public.file_extras ON public.file.id = public.file_extras.id
    LEFT JOIN public.docket_documents ON public.file.id = public.docket_documents.file_id
    LEFT JOIN public.relation_documents_organizations_authorship ON public.file.id = public.relation_documents_organizations_authorship.document_id
    LEFT JOIN public.organization ON public.relation_documents_organizations_authorship.organization_id = public.organization.id
WHERE public.file.id = $1
`

type SemiCompleteFileGetRow struct {
	ID               pgtype.UUID
	Name             pgtype.Text
	Extension        pgtype.Text
	Lang             pgtype.Text
	Verified         pgtype.Bool
	Hash             pgtype.Text
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	Mdata            []byte
	ExtraObj         []byte
	DocketUuid       pgtype.UUID
	IsPrimaryAuthor  pgtype.Bool
	OrganizationID   pgtype.UUID
	OrganizationName pgtype.Text
	IsPerson         pgtype.Bool
}

func (q *Queries) SemiCompleteFileGet(ctx context.Context, id pgtype.UUID) ([]SemiCompleteFileGetRow, error) {
	rows, err := q.db.Query(ctx, semiCompleteFileGet, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SemiCompleteFileGetRow
	for rows.Next() {
		var i SemiCompleteFileGetRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Extension,
			&i.Lang,
			&i.Verified,
			&i.Hash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Mdata,
			&i.ExtraObj,
			&i.DocketUuid,
			&i.IsPrimaryAuthor,
			&i.OrganizationID,
			&i.OrganizationName,
			&i.IsPerson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
