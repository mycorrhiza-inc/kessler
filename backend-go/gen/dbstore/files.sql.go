// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: files.sql

package dbstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addStageLog = `-- name: AddStageLog :one
WITH inserted_log AS (
	INSERT INTO public.stage_log (
			stage_id,
			status,
			log
		)
	VALUES ($1, $2, $3)
	RETURNING id,
		stage_id,
		status
)
UPDATE public.filestage fs
SET status = il.status
FROM inserted_log il
WHERE fs.id = il.stage_id
RETURNING il.id
`

type AddStageLogParams struct {
	StageID pgtype.UUID
	Status  NullStageState
	Log     []byte
}

// used to log the state of a file processing stage and update filestage status
func (q *Queries) AddStageLog(ctx context.Context, arg AddStageLogParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, addStageLog, arg.StageID, arg.Status, arg.Log)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO public.file (
		id,
		extension,
		lang,
		name,
		stage_id,
		isPrivate,
    hash,
		created_at,
		updated_at
	)
VALUES (
		gen_random_uuid(),
		$1,
		$2,
		$3,
		$4,
		$5,
    $6,
		NOW(),
		NOW()
	)
RETURNING id
`

type CreateFileParams struct {
	Extension pgtype.Text
	Lang      pgtype.Text
	Name      pgtype.Text
	StageID   pgtype.UUID
	Isprivate pgtype.Bool
	Hash      pgtype.Text
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.Extension,
		arg.Lang,
		arg.Name,
		arg.StageID,
		arg.Isprivate,
		arg.Hash,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM public.file
WHERE id = $1
`

func (q *Queries) DeleteFile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFile, id)
	return err
}

const fetchMetadata = `-- name: FetchMetadata :one
SELECT id, isprivate, mdata, created_at, updated_at
FROM public.file_metadata
WHERE id = $1
`

func (q *Queries) FetchMetadata(ctx context.Context, id pgtype.UUID) (FileMetadatum, error) {
	row := q.db.QueryRow(ctx, fetchMetadata, id)
	var i FileMetadatum
	err := row.Scan(
		&i.ID,
		&i.Isprivate,
		&i.Mdata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertMetadata = `-- name: InsertMetadata :one
INSERT INTO public.file_metadata (
    id,
    isPrivate,
    mdata,
    created_at,
    updated_at
)
VALUES (
    $1,
    $2,
    $3,
    NOW(),
    NOW()
)
RETURNING id
`

type InsertMetadataParams struct {
	ID        pgtype.UUID
	Isprivate pgtype.Bool
	Mdata     []byte
}

func (q *Queries) InsertMetadata(ctx context.Context, arg InsertMetadataParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertMetadata, arg.ID, arg.Isprivate, arg.Mdata)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const listFiles = `-- name: ListFiles :many
SELECT id, lang, name, extension, stage_id, isprivate, created_at, updated_at, hash
FROM public.file
ORDER BY updated_at DESC
`

func (q *Queries) ListFiles(ctx context.Context) ([]File, error) {
	rows, err := q.db.Query(ctx, listFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Lang,
			&i.Name,
			&i.Extension,
			&i.StageID,
			&i.Isprivate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnprocessedFiles = `-- name: ListUnprocessedFiles :many
SELECT file.id, lang, name, extension, file.stage_id, isprivate, file.created_at, updated_at, hash, sl.id, sl.stage_id, status, log, sl.created_at
FROM public.file
	LEFT JOIN public.stage_log sl ON f.stage_id = sl.stage_id
WHERE sl.status != 'completed'
ORDER BY sl.created_at DESC
`

type ListUnprocessedFilesRow struct {
	ID          pgtype.UUID
	Lang        pgtype.Text
	Name        pgtype.Text
	Extension   pgtype.Text
	StageID     pgtype.UUID
	Isprivate   pgtype.Bool
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	Hash        pgtype.Text
	ID_2        pgtype.UUID
	StageID_2   pgtype.UUID
	Status      NullStageState
	Log         []byte
	CreatedAt_2 pgtype.Timestamptz
}

// get all files that are not in the completed stage
// use a left join to get the stage status
func (q *Queries) ListUnprocessedFiles(ctx context.Context) ([]ListUnprocessedFilesRow, error) {
	rows, err := q.db.Query(ctx, listUnprocessedFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUnprocessedFilesRow
	for rows.Next() {
		var i ListUnprocessedFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.Lang,
			&i.Name,
			&i.Extension,
			&i.StageID,
			&i.Isprivate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hash,
			&i.ID_2,
			&i.StageID_2,
			&i.Status,
			&i.Log,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnprocessedFilesPagnated = `-- name: ListUnprocessedFilesPagnated :many
SELECT file.id, lang, name, extension, file.stage_id, isprivate, file.created_at, updated_at, hash, sl.id, sl.stage_id, status, log, sl.created_at
FROM public.file
	LEFT JOIN public.stage_log sl ON f.stage_id = sl.stage_id
WHERE sl.status != 'completed'
ORDER BY sl.created_at DESC
LIMIT $1 OFFSET $2
`

type ListUnprocessedFilesPagnatedParams struct {
	Limit  int32
	Offset int32
}

type ListUnprocessedFilesPagnatedRow struct {
	ID          pgtype.UUID
	Lang        pgtype.Text
	Name        pgtype.Text
	Extension   pgtype.Text
	StageID     pgtype.UUID
	Isprivate   pgtype.Bool
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	Hash        pgtype.Text
	ID_2        pgtype.UUID
	StageID_2   pgtype.UUID
	Status      NullStageState
	Log         []byte
	CreatedAt_2 pgtype.Timestamptz
}

func (q *Queries) ListUnprocessedFilesPagnated(ctx context.Context, arg ListUnprocessedFilesPagnatedParams) ([]ListUnprocessedFilesPagnatedRow, error) {
	rows, err := q.db.Query(ctx, listUnprocessedFilesPagnated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUnprocessedFilesPagnatedRow
	for rows.Next() {
		var i ListUnprocessedFilesPagnatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Lang,
			&i.Name,
			&i.Extension,
			&i.StageID,
			&i.Isprivate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hash,
			&i.ID_2,
			&i.StageID_2,
			&i.Status,
			&i.Log,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readFile = `-- name: ReadFile :one
SELECT id, lang, name, extension, stage_id, isprivate, created_at, updated_at, hash
FROM public.file
WHERE id = $1
`

func (q *Queries) ReadFile(ctx context.Context, id pgtype.UUID) (File, error) {
	row := q.db.QueryRow(ctx, readFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Lang,
		&i.Name,
		&i.Extension,
		&i.StageID,
		&i.Isprivate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const updateFile = `-- name: UpdateFile :one
UPDATE public.file
SET extension = $1,
	lang = $2,
	name = $3,
	stage_id = $4,
	isPrivate = $5,
  hash = $6,
	updated_at = NOW()
WHERE id = $6
RETURNING id
`

type UpdateFileParams struct {
	Extension pgtype.Text
	Lang      pgtype.Text
	Name      pgtype.Text
	StageID   pgtype.UUID
	Isprivate pgtype.Bool
	Hash      pgtype.Text
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, updateFile,
		arg.Extension,
		arg.Lang,
		arg.Name,
		arg.StageID,
		arg.Isprivate,
		arg.Hash,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const updateMetadata = `-- name: UpdateMetadata :one
UPDATE public.file_metadata
SET isPrivate = $1,
    mdata = $2,
    updated_at = NOW()
WHERE id = $3
RETURNING id
`

type UpdateMetadataParams struct {
	Isprivate pgtype.Bool
	Mdata     []byte
	ID        pgtype.UUID
}

func (q *Queries) UpdateMetadata(ctx context.Context, arg UpdateMetadataParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, updateMetadata, arg.Isprivate, arg.Mdata, arg.ID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
