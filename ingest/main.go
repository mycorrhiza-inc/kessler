package main

import (
	"log"
	"net/http"

	"github.com/gorilla/mux"
	_ "github.com/swaggo/http-swagger/example/gorilla/docs" // docs is generated by Swag CLI, you have to import it.
	httpSwagger "github.com/swaggo/http-swagger/v2"
)

//	@title			Swagger Example API
//	@version		1.0
//	@description	This is a sample server Petstore server.
//	@termsOfService	http://swagger.io/terms/

//	@contact.name	API Support
//	@contact.url	http://www.swagger.io/support
//	@contact.email	support@swagger.io

//	@license.name	Apache 2.0
//	@license.url	http://www.apache.org/licenses/LICENSE-2.0.html

// @host		petstore.swagger.io
// @BasePath	/v2
func main() {
	r := mux.NewRouter()
	root := "/ingest_v1"

	r.PathPrefix(root + "/swagger").Handler(httpSwagger.Handler(
		httpSwagger.URL("http://localhost/ingest_v1/swagger/doc.json"), // The url pointing to API definition
		httpSwagger.DeepLinking(true),
		httpSwagger.DocExpansion("none"),
		httpSwagger.DomID("swagger-ui"),
	)).Methods(http.MethodGet)

	log.Fatal(http.ListenAndServe(":4042", r))
}

// const (
// 	redisAddr    = "127.0.0.1:6379"
// 	concurrency  = 30 // Max concurrent tasks
// )
//
// func main() {
// 	// Create asyncq client
// 	client := asynq.NewClient(asynq.RedisClientOpt{Addr: redisAddr})
// 	defer client.Close()
//
// 	// Create and start worker
// 	worker := asynq.NewServer(
// 		asynq.RedisClientOpt{Addr: redisAddr},
// 		asynq.Config{
// 			Concurrency: concurrency,
// 			Queues: map[string]int{
// 				"default": 1,
// 			},
// 		},
// 	)
//
// 	// Create mux and register handlers
// 	mux := asynq.NewServeMux()
// 	mux.Use(tasksMiddleware(client))
// 	mux.HandleFunc(tasks.TypeAddFileScraper, tasks.HandleAddFileScraperTask)
// 	mux.HandleFunc(tasks.TypeProcessExistingFile, tasks.HandleProcessFileTask)
//
// 	// Run worker in separate goroutine
// 	go func() {
// 		if err := worker.Run(mux); err != nil {
// 			log.Fatalf("Failed to start worker: %v", err)
// 		}
// 	}()
//
// 	// Set up shutdown handling
// 	quit := make(chan os.Signal, 1)
// 	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
// 	<-quit
// 	log.Println("Shutting down...")
// 	worker.Shutdown()
// }
//
// func tasksMiddleware(client *asynq.Client) asynq.MiddlewareFunc {
// 	return func(h asynq.Handler) asynq.Handler {
// 		return asynq.HandlerFunc(func(ctx context.Context, t *asynq.Task) error {
// 			ctx = tasks.WithClient(ctx, client)
// 			return h.ProcessTask(ctx, t)
// 		})
// 	}
// }
