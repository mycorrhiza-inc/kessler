package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"kessler/internal/admin"
	"kessler/internal/autocomplete"
	"kessler/internal/cache"
	"kessler/internal/dbstore"
	"kessler/internal/health"
	indexing "kessler/internal/ingest/indexing"
	"kessler/internal/jobs"
	"kessler/internal/objects"
	ConversationsHandler "kessler/internal/objects/conversations/handler"
	FilesHandler "kessler/internal/objects/files/handler"
	OrganizationsHandler "kessler/internal/objects/organizations/handler"
	"kessler/internal/search"
	"kessler/pkg/database"
	"kessler/pkg/logger"

	_ "kessler/cmd/server/docs" // docs is generated by Swag CLI, you have to import it.

	"github.com/gorilla/mux"
	httpSwagger "github.com/swaggo/http-swagger"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
)

//	@title			Kessler API
//	@version		1.0
//	@description	Kessler Backend API with FuguDB Integration
//	@termsOfService	http://swagger.io/terms/

//	@contact.name	Kessler API Support
//	@contact.url	https://kessler.xyz
//	@contact.email	support@kessler.xyz

//	@license.name	Apache 2.0
//	@license.url	http://www.apache.org/licenses/LICENSE-2.0.html

// @host		localhost:4041
// @BasePath	""

const (
	defaultPort     = "4041"
	standardTimeout = 20 * time.Second
	adminTimeout    = 10 * time.Minute
	shutdownTimeout = 30 * time.Second
)

// AppDependencies holds all the dependencies needed by the application
type AppDependencies struct {
	DB    dbstore.DBTX
	Cache cache.CacheController
}

func main() {
	// Initialize logger first
	if err := logger.Init(logger.DefaultConfig()); err != nil {
		log.Fatalf("Failed to initialize logger: %v", err)
	}
	defer logger.Sync()

	// Create root context with logger
	ctx := logger.WithLogger(context.Background())
	log := logger.FromContext(ctx)

	log.InfoContext(ctx, "Starting application",
		zap.String("env", os.Getenv("GO_ENV")),
		zap.String("port", getPort()),
	)

	// Initialize dependencies
	deps, err := initDependencies(ctx)
	if err != nil {
		log.FatalContext(ctx, "Failed to initialize dependencies", zap.Error(err))
	}

	// Setup router and middleware with dependencies
	router := setupRouter(ctx, deps)

	// Create server
	server := &http.Server{
		Addr:         ":" + getPort(),
		Handler:      router,
		ReadTimeout:  adminTimeout,
		WriteTimeout: adminTimeout,
	}

	// Start server in goroutine
	serverErrors := make(chan error, 1)
	go func() {
		log.InfoContext(ctx, "Server starting", zap.String("address", server.Addr))
		serverErrors <- server.ListenAndServe()
	}()

	// Wait for interrupt signal or server error
	shutdown := make(chan os.Signal, 1)
	signal.Notify(shutdown, os.Interrupt, syscall.SIGTERM)

	select {
	case err := <-serverErrors:
		if err != http.ErrServerClosed {
			log.ErrorContext(ctx, "Server failed", zap.Error(err))
		}
	case sig := <-shutdown:
		log.InfoContext(ctx, "Shutdown signal received", zap.String("signal", sig.String()))

		// Graceful shutdown
		shutdownCtx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
		defer cancel()

		if err := server.Shutdown(shutdownCtx); err != nil {
			log.ErrorContext(ctx, "Graceful shutdown failed", zap.Error(err))
			server.Close()
		}
	}

	log.InfoContext(ctx, "Application stopped")
}

func initDependencies(ctx context.Context) (*AppDependencies, error) {
	log := logger.FromContext(ctx)

	// Initialize database
	log.InfoContext(ctx, "Connecting to database")
	pool, err := database.Init(30)
	if err != nil {
		return nil, fmt.Errorf("database initialization failed: %w", err)
	}
	log.InfoContext(ctx, "Database connection successful")

	// Initialize cache
	log.InfoContext(ctx, "Initializing memcached")
	if err := cache.InitMemcached("localhost:11211"); err != nil {
		return nil, fmt.Errorf("memcached initialization failed: %w", err)
	}

	// Create cache controller
	cacheController, err := cache.NewCacheController()
	if err != nil {
		log.WarnContext(ctx, "Failed to create cache controller", zap.Error(err))
		// Continue without cache - it's optional
	}

	// Test cache connection
	if cacheController.Client != nil {
		if err := cacheController.Client.Ping(); err != nil {
			log.WarnContext(ctx, "Cache ping failed", zap.Error(err))
		} else {
			log.InfoContext(ctx, "Cache initialized and tested successfully")
		}
	}

	return &AppDependencies{
		DB:    pool,
		Cache: cacheController,
	}, nil
}

// Add debug middleware to see all incoming requests
func debugMiddleware() func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			fmt.Printf("ðŸ” INCOMING REQUEST: %s %s\n", r.Method, r.URL.Path)
			fmt.Printf("ðŸ” DEBUG: %s %s\n", r.Method, r.URL.Path)
			fmt.Printf("ðŸ” Headers: %v\n", r.Header)
			next.ServeHTTP(w, r)
		})
	}
}

func setupRouter(ctx context.Context, deps *AppDependencies) http.Handler {
	log := logger.FromContext(ctx) // set up logger

	r := mux.NewRouter()
	r.StrictSlash(true) // handle trailing slashes

	// Add debug middleware first to see all requests
	r.Use(debugMiddleware())

	// Apply global middleware in correct order
	r.Use(logger.Middleware())        // Add logger to context first
	r.Use(logger.TracingMiddleware()) // Then tracing (uses logger from context)
	r.Use(corsMiddleware())           // Finally CORS

	// Set up Swagger endpoint
	r.PathPrefix("/swagger/").Handler(httpSwagger.Handler(
		httpSwagger.URL("doc.json"), // URL relative to the UI
		httpSwagger.DeepLinking(true),
		httpSwagger.DocExpansion("none"),
		httpSwagger.DomID("swagger-ui"),
	)).Methods(http.MethodGet)

	// Create standard subrouter with timeout
	standardRoute := r.PathPrefix("").Subrouter()
	standardRoute.Use(timeoutMiddleware(standardTimeout))

	// Register route groups with dependencies
	registerPublicRoutes(standardRoute, log, deps)
	registerSystemRoutes(standardRoute, log, deps)
	registerAdminRoutes(standardRoute, log, deps)

	// indexing.RegisterIndexingRoutes(standardRoute)

	// Add a catch-all debug route to see what's not matching
	r.PathPrefix("/").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Printf("ðŸš¨ CATCH-ALL: %s %s (no route matched)\n", r.Method, r.URL.Path)
		w.WriteHeader(http.StatusNotFound)
		fmt.Fprintf(w, "No route found for %s %s", r.Method, r.URL.Path)
	})

	log.InfoContext(ctx, "All routes registered successfully")

	// Print all registered routes for debugging
	printRoutes(r)

	return r
}

// Add route printing function
func printRoutes(r *mux.Router) {
	fmt.Println("ðŸ“‹ Registered routes:")
	r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
		pathTemplate, err := route.GetPathTemplate()
		if err == nil {
			methods, _ := route.GetMethods()
			fmt.Printf("   %s %v\n", pathTemplate, methods)
		}
		return nil
	})
}

func registerPublicRoutes(router *mux.Router, log *otelzap.Logger, deps *AppDependencies) {
	fmt.Println("ðŸ”§ Registering public routes...")

	// Public API routes - pass DB to handlers that need it
	publicSubroute := router.PathPrefix("/public").Subrouter()
	FilesHandler.DefineFileRoutes(
		publicSubroute.PathPrefix("/files").Subrouter(),
		deps.DB,
	)
	OrganizationsHandler.DefineOrganizationRoutes(
		publicSubroute.PathPrefix("/organizations").Subrouter(),
		deps.DB)
	ConversationsHandler.DefineConversationsRoutes(
		publicSubroute.PathPrefix("/conversations").Subrouter(),
		deps.DB)
	fmt.Println("   âœ… Public CRUD routes registered")

	// Search routes - pass DB to search
	searchSubroute := router.PathPrefix("/search").Subrouter()
	if err := search.RegisterSearchRoutes(searchSubroute, deps.DB); err != nil {
		log.ErrorContext(context.Background(), "Failed to register search routes", zap.Error(err))
	}
	v2SearchSubroute := router.PathPrefix("/v2/search").Subrouter()
	if err := search.RegisterSearchRoutes(v2SearchSubroute, deps.DB); err != nil {
		log.ErrorContext(context.Background(), "Failed to register v2 search routes", zap.Error(err))
	}
	fmt.Println("   âœ… Search routes registered")

	// Object routes (directly access Fugu objects)
	objectsSubroute := router.PathPrefix("/objects").Subrouter()
	objects.RegisterObjectRoutes(objectsSubroute)
	fmt.Println("   âœ… Object routes registered")

	autocomplete.DefineAutocompleteRoutes(
		router.PathPrefix("/autocomplete").Subrouter(),
	)
	fmt.Println("   âœ… Autocomplete routes registered")

	// Jobs routes - pass DB if needed
	jobSubroute := router.PathPrefix("/jobs").Subrouter()
	jobs.DefineJobRoutes(jobSubroute, deps.DB) // Assuming jobs.DefineJobRoutes accepts dbstore.DBTX
	fmt.Println("   âœ… Job routes registered")
}

func registerSystemRoutes(router *mux.Router, log *otelzap.Logger, deps *AppDependencies) {
	fmt.Println("ðŸ”§ Registering system routes...")

	// Health check routes - pass DB for health checks
	healthSubroute := router.PathPrefix("/health").Subrouter()
	health.DefineHealthRoutes(healthSubroute, deps.DB)
	fmt.Println("   âœ… Health routes registered")

	// Version endpoint
	router.HandleFunc("/version_hash", handleVersionHash)
	fmt.Println("   âœ… Version endpoint registered")
}

func registerAdminRoutes(router *mux.Router, log *otelzap.Logger, deps *AppDependencies) {
	fmt.Println("ðŸ”§ Registering admin routes...")

	// Admin routes with longer timeout
	adminRoute := router.PathPrefix("/admin").Subrouter()
	adminRoute.Use(timeoutMiddleware(adminTimeout))
	admin.DefineAdminRoutes(adminRoute, deps.DB) // Assuming admin.DefineAdminRoutes accepts dbstore.DBTX
	// Admin indexing endpoints
	indexing.RegisterIndexingRoutes(adminRoute, deps.DB)
	fmt.Println("   âœ… Admin routes registered")
}

func corsMiddleware() func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			domain := os.Getenv("DOMAIN")
			origin := "*"
			if domain != "" {
				origin = "https://" + domain
			}

			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, Origin")
			w.Header().Set("Access-Control-Allow-Credentials", "true")

			if r.Method == http.MethodOptions {
				w.WriteHeader(http.StatusOK)
				return
			}

			next.ServeHTTP(w, r)
		})
	}
}

func timeoutMiddleware(timeout time.Duration) mux.MiddlewareFunc {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			ctx, cancel := context.WithTimeout(r.Context(), timeout)
			defer cancel()

			r = r.WithContext(ctx)

			done := make(chan bool, 1)
			go func() {
				defer func() {
					if recover() != nil {
						done <- true
					}
				}()
				next.ServeHTTP(w, r)
				done <- true
			}()

			select {
			case <-ctx.Done():
				w.WriteHeader(http.StatusGatewayTimeout)
				fmt.Fprintf(w, "Request timeout after %v\n", timeout)
			case <-done:
			}
		})
	}
}

func handleVersionHash(w http.ResponseWriter, r *http.Request) {
	versionHash := os.Getenv("VERSION_HASH")
	if versionHash == "" {
		versionHash = "unknown"
	}
	w.Write([]byte(versionHash))
}

func getPort() string {
	if port := os.Getenv("PORT"); port != "" {
		return port
	}
	return defaultPort
}
