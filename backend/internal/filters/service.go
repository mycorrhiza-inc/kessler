package filters

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"kessler/internal/dbstore"
	"kessler/pkg/database"
	"kessler/pkg/logger"
	"strings"

	"github.com/bradfitz/gomemcache/memcache"
	"go.uber.org/zap"
)

// Common errors that can be returned by the FilterService
var (
	ErrFilterNotFound     = fmt.Errorf("filter not found")
	ErrInvalidFilterState = fmt.Errorf("invalid filter state")
	ErrDatabaseOperation  = fmt.Errorf("database operation failed")
)

// FilterService handles business logic for filters
type FilterService struct {
	db          dbstore.DBTX
	registry    *FilterRegistry
	queryEngine *dbstore.Queries // This will be generated by sqlc
}

var log = logger.Named("main")

// NewFilterService creates a new instance of FilterService
func NewFilterService(ctx context.Context, db dbstore.DBTX, cache *memcache.Client) *FilterService {
	registry, err := NewFilterRegistry(cache)
	if err != nil {
		logger.Fatal(ctx, "unable to load filter field", zap.Error(err))
	}

	qe := database.GetQueries(db)

	return &FilterService{
		db:          db,
		registry:    registry,
		queryEngine: qe,
	}
}

func (s *FilterService) RegisterDefaultFilters() error {
	// daterange filter
	err := s.registry.Register("daterange", NewDateRangeFilter())
	if err != nil {
		logger.Error("failed to register date range filter",
			zap.Error(err))
		return fmt.Errorf("failed to register date range filter: %w", err)
	}

	err = s.registry.Register("text", NewTextFilter())
	if err != nil {
		s.logger.Error("failed to register text filter",
			zap.Error(err))
		return fmt.Errorf("failed to register text filter: %w", err)
	}

	return nil
}

func (s *FilterService) AddFilterToState(ctx context.Context, stateAbbrev string) error {
	state := strings.ToUpper(stateAbbrev)
	cacheKey := fmt.Sprintf("filters:state:%s", state)
	logger.Debug(ctx, fmt.Sprintf("adding filter to %s", stateAbbrev), zap.String("filter key", cacheKey))

	s.registry.mcClient.Set(&memcache.Item{
		Key:   cacheKey,
		Value: []byte{},
	})

	return nil
}

// GetFiltersByDataset retrieves filters by their state
func (s *FilterService) GetFiltersByDataset(ctx context.Context, stateAbbrev string) ([]dbstore.Filter, error) {
	if stateAbbrev == "" {
		return nil, fmt.Errorf("%w: empty state", ErrInvalidFilterState)
	}
	state := strings.ToUpper(stateAbbrev)

	// Try cache first
	cacheKey := fmt.Sprintf("filters:state:%s", state)
	if item, err := s.registry.mcClient.Get(cacheKey); err == nil {
		var filters []dbstore.Filter
		if err := json.Unmarshal(item.Value, &filters); err == nil {
			s.logger.Debug("cache hit for filters", zap.String("state", state))
			return filters, nil
		}
	}

	// If cache-miss, preform the query
	filters, err := s.queryEngine.GetFiltersByDataset(ctx, state)
	if err != nil {
		if err == sql.ErrNoRows {
			return []dbstore.Filter{}, nil
		}
		s.logger.Error("failed to fetch filters",
			zap.String("state", state),
			zap.Error(err))
		return nil, fmt.Errorf("%w: %v", ErrDatabaseOperation, err)
	}

	// Cache the results
	if cacheData, err := json.Marshal(filters); err == nil {
		s.registry.mcClient.Set(&memcache.Item{
			Key:        cacheKey,
			Value:      cacheData,
			Expiration: 300, // 5 minute TTL
		})
	}

	return filters, nil
}
